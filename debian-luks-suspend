#!/bin/bash 

set -e -u
trap 'echo "Press ENTER to continue."; read dummy' ERR



INITRAMFS_BASE_DIR="/run/initramfs/"
INITRAMFS_DIR=$(mktemp -d -p ${INITRAMFS_BASE_DIR} )
SYSTEM_SLEEP_PATH=/lib/systemd/system-sleep
SYSTEM_SLEEP_BINARY=/lib/systemd/systemd-sleep
SUSPEND_SCRIPT=bin/encrypt-on-suspend
BIND_PATHS="/sys /proc /dev /run"
REMOUNT=0
# Retrieve cryptdevice name from boot cmdline
ROOT_CRYPT_DEVICE="$(sed -n 's/.*root=\([^: ]*\).*$/\1/p' /proc/cmdline)"
CRYPTNAME="$(pvdisplay -C -o pv_name --noheadings | tr -d ' ' | cut -d\/ -f4)"

# run_dir DIR ARGS...
# Run all executable scripts in directory DIR with arguments ARGS
run_dir() {
    local dir=$1
    shift
    find "${dir}" -type f -executable -exec "{}" "$@" ";"
}

# Restore chroot
umount_initramfs() {
    umount -R "${INITRAMFS_DIR}"
    rmdir "${INITRAMFS_DIR}"
}

ext4_cryptdevice_mount_options() {
    local mt="$(grep "^${1} " /proc/mounts | cut -d ' ' -f 3,4)"
    if [[ "${mt:0:5}" == "ext4 " ]]; then
        echo "${mt:5}"
    fi
}

mount_initramfs() {
    local INITRAMFS=`sed -n 's/.*BOOT_IMAGE=.*vmlinuz-\([^: ]*\).*$/\/boot\/initrd.img-\1/p' /proc/cmdline`
    mkdir -p  ${INITRAMFS_DIR}
    mount -t tmpfs -o size=512m tmpfs ${INITRAMFS_DIR}
    
    # extracts hybrid initrd.img to initramfs dir
    if file -L ${INITRAMFS} | grep -q "ASCII cpio archive"; then
        (cd ${INITRAMFS_DIR} &&
            SKIP_BLOCKS=$(cpio -id < "${INITRAMFS}" 2>&1 | grep blocks | cut -d" " -f1) &&
            dd status=none if="${INITRAMFS}" of="${INITRAMFS_DIR}/initrd.img.gz" bs=512 skip=$SKIP_BLOCKS 
            zcat "${INITRAMFS_DIR}/initrd.img.gz" | cpio -id --quiet 
            rm "${INITRAMFS_DIR}/initrd.img.gz")
    else           
        (cd ${INITRAMFS_DIR} &&  zcat ${INITRAMFS} | cpio -id --quiet)
    fi

    for p in ${BIND_PATHS}; do
        mkdir -p "${INITRAMFS_DIR}${p}"
        mount -o bind ${p} "${INITRAMFS_DIR}${p}"
    done
}
## Main script
trap umount_initramfs EXIT

# extract temporary filesystem to switch to
mount_initramfs

[ -e "${INITRAMFS_DIR}/$SUSPEND_SCRIPT" ] || exec $SYSTEM_SLEEP_BINARY suspend

# Run pre-suspend scripts
run_dir "${SYSTEM_SLEEP_PATH}" pre suspend

# Stop udev service and prevent it to be autostarted.
# Otherwise, luksResume will hang waiting for udev, which is itself waiting
# for I/O on the root device.
# Likewise with journald service.
systemctl stop bluetooth
systemctl stop systemd-udevd-control.socket
systemctl stop systemd-udevd-kernel.socket
systemctl stop systemd-udevd.service
journalctl --sync
systemctl stop systemd-journald.socket
systemctl stop systemd-journald-dev-log.socket
systemctl stop systemd-journald-audit.socket
systemctl stop systemd-journald 

# Journalled ext4 filesystems in kernel versions 3.11+ will block suspend
# if mounted with `barrier=1`, which is the default. Temporarily remount with
# `barrier=0` if this is true of the crypt fs.
MOUNT_OPTS="$(ext4_cryptdevice_mount_options "$ROOT_CRYPT_DEVICE")"
if [[ "$MOUNT_OPTS" ]] && ! [[ "$MOUNT_OPTS" == *nobarrier* || "$MOUNT_OPTS" == *barrier=0* ]]; then
    REMOUNT=1
    mount -o remount,"$MOUNT_OPTS",barrier=0 /
fi

# Hand over execution to script inside initramfs
(cd "${INITRAMFS_DIR}" && chroot . /$SUSPEND_SCRIPT "$CRYPTNAME")

# Restore original mount options if necessary
if ((REMOUNT)); then
    mount -o remount,"$MOUNT_OPTS",barrier=1 /
fi

# Restart services
systemctl start systemd-journald.socket
systemctl start systemd-journald-dev-log.socket
systemctl start systemd-journald-audit.socket
systemctl start systemd-journald.service
systemctl start systemd-udevd-control.socket
systemctl start systemd-udevd-kernel.socket
systemctl start systemd-udevd.service
systemctl start bluetooth

# Run post-suspend scripts
run_dir "${SYSTEM_SLEEP_PATH}" post suspend

# pkill systemd-udevd because I can't figure out why it won't stop while inside the chroot
pkill -f '/lib/systemd/systemd-udevd --daemon --resolve-names=never'

# Unlock user sessions
loginctl unlock-sessions
